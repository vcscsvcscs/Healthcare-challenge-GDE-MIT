# Design Document: Eva Health Assistant Backend

## Overview

Eva Health Assistant backend is a Go-based REST API that powers a voice-first health data aggregation platform for Hungarian users. The system manages conversational health check-ins, stores structured health data in PostgreSQL, and generates professional medical reports in PDF format.

The architecture follows a clean, layered approach with clear separation between API handlers, business logic, data access, and external service integrations. The API contract is defined using OpenAPI 3.0 specification, with server code generated using oapi-codegen to ensure type safety and consistency between documentation and implementation.

### Key Technologies

- **Language**: Go 1.26+
- **Web Framework**: Gin (via oapi-codegen generated handlers)
- **Database**: PostgreSQL 15+ with pgx driver
- **API Specification**: OpenAPI 3.0 with oapi-codegen code generation
- **Azure Services**: Azure OpenAI (GPT-4o or GPT-4.1), Azure Speech Service (Speech-to-Text, Text-to-Speech), Azure Blob Storage
- **Audio Streaming**: WebSocket or HTTP chunked transfer for real-time audio streaming
- **PDF Generation**: go-pdf/fpdf or similar library
- **Migration Tool**: golang-migrate
- **Configuration**: Environment variables with viper

## Architecture

### High-Level Architecture

```mermaid
graph TB
    Mobile[Flutter Mobile App] -->|Audio Stream| WS[WebSocket/HTTP Stream]
    WS --> Handler[Handler Layer]
    Mobile -->|HTTPS/JSON| API[API Layer - Gin]
    API --> Handler
    Handler --> Service[Service Layer]
    Service --> Repo[Repository Layer]
    Service --> Azure[Azure OpenAI Client]
    Service --> Speech[Azure Speech Service]
    Service --> Blob[Azure Blob Storage]
    Speech -->|Transcription| Service
    Service -->|TTS Request| Speech
    Speech -->|Audio Response| Service
    Repo --> DB[(PostgreSQL)]
    Service --> PDF[PDF Generator]
    Blob -->|Store Audio| Service
```

### Layer Responsibilities

1. **API Layer** (Generated by oapi-codegen)
   - Request/response type definitions
   - Request validation against OpenAPI schema
   - Route registration with Gin
   - HTTP status code handling

2. **Handler Layer** (Manual implementation)
   - HTTP request/response mapping
   - Error translation to HTTP responses
   - Request context management
   - Logging and metrics

3. **Service Layer** (Business logic)
   - Conversation state management
   - AI data extraction orchestration
   - Report generation logic
   - Business rule validation
   - Transaction coordination

4. **Repository Layer** (Data access)
   - Database queries and mutations
   - Data model mapping
   - Transaction management
   - Query optimization

5. **External Service Clients**
   - Azure OpenAI client wrapper
   - Azure Blob Storage client wrapper
   - Error handling and retry logic

## Components and Interfaces

### 1. API Layer (OpenAPI + oapi-codegen)

**OpenAPI Specification Location**: `/api/openapi.json`

**Code Generation Configuration**: `/apps/backend/pkg/api/oapi-codegen-cfg.yaml`

```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/oapi-codegen/oapi-codegen/HEAD/configuration-schema.json
package: api
output: api.gen.go
generate:
  models: true
  gin-server: true
```

**Generation Command**:
```go
//go:generate go run github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen -config oapi-codegen-cfg.yaml ../../../../api/openapi.json
```

**Key API Endpoints** (defined in OpenAPI):

- `POST /api/v1/checkin/start` - Start new check-in session, returns first question with audio
- `POST /api/v1/checkin/audio-stream` - Stream audio from mobile app (WebSocket or chunked upload)
- `POST /api/v1/checkin/respond` - Submit transcribed user response, returns next question with audio
- `GET /api/v1/checkin/status/{sessionId}` - Get session status
- `POST /api/v1/checkin/complete` - Complete check-in
- `GET /api/v1/checkin/question-audio/{sessionId}/{questionId}` - Get pre-generated question audio
- `POST /api/v1/health/medications` - Add medication
- `GET /api/v1/health/medications` - List medications
- `PUT /api/v1/health/medications/{id}` - Update medication
- `DELETE /api/v1/health/medications/{id}` - Delete medication
- `POST /api/v1/health/menstruation` - Log menstruation data
- `GET /api/v1/health/menstruation` - Get menstruation history
- `POST /api/v1/health/blood-pressure` - Log blood pressure
- `GET /api/v1/health/blood-pressure` - Get blood pressure history
- `POST /api/v1/health/fitness-sync` - Sync fitness data from Health Connect (Google Fit)
- `GET /api/v1/health/fitness` - Get fitness data history
- `GET /api/v1/dashboard/summary` - Get dashboard summary
- `GET /api/v1/dashboard/trends` - Get trend analysis
- `POST /api/v1/reports/generate` - Generate report
- `GET /api/v1/reports/{id}` - Download report

### 2. Handler Layer

**Interface**: Implements ServerInterface generated by oapi-codegen

```go
package handler

type CheckInHandler struct {
    service *service.CheckInService
    logger  *zap.Logger
}

func NewCheckInHandler(service *service.CheckInService, logger *zap.Logger) *CheckInHandler

// Implements generated ServerInterface methods
func (h *CheckInHandler) PostApiV1CheckinStart(c *gin.Context)
func (h *CheckInHandler) PostApiV1CheckinAudioStream(c *gin.Context) // WebSocket or chunked upload
func (h *CheckInHandler) PostApiV1CheckinRespond(c *gin.Context)
func (h *CheckInHandler) GetApiV1CheckinStatusSessionId(c *gin.Context, sessionId string)
func (h *CheckInHandler) GetApiV1CheckinQuestionAudioSessionIdQuestionId(c *gin.Context, sessionId, questionId string)
func (h *CheckInHandler) PostApiV1CheckinComplete(c *gin.Context)
```

**Audio Streaming Handler**:

The audio streaming endpoint handles real-time audio from the mobile app:

```go
func (h *CheckInHandler) PostApiV1CheckinAudioStream(c *gin.Context) {
    sessionID := c.Query("session_id")
    
    // Option 1: WebSocket for bidirectional streaming
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        h.logger.Error("websocket upgrade failed", "error", err)
        return
    }
    defer conn.Close()
    
    // Stream audio chunks to Azure Speech Service
    transcription, err := h.service.StreamAudioToSpeech(c.Request.Context(), sessionID, conn)
    if err != nil {
        h.logger.Error("audio streaming failed", "error", err)
        return
    }
    
    // Send transcription back to client
    conn.WriteJSON(map[string]string{"transcription": transcription})
}
```

**Question Audio Handler**:

Returns pre-generated or on-demand generated audio for questions:

```go
func (h *CheckInHandler) GetApiV1CheckinQuestionAudioSessionIdQuestionId(c *gin.Context, sessionID, questionID string) {
    audioData, err := h.service.GetQuestionAudio(c.Request.Context(), sessionID, questionID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, ErrorResponse{
            Code:    "AUDIO_GENERATION_FAILED",
            Message: "Failed to generate question audio",
        })
        return
    }
    
    c.Header("Content-Type", "audio/wav")
    c.Header("Content-Length", fmt.Sprintf("%d", len(audioData)))
    c.Data(http.StatusOK, "audio/wav", audioData)
}
```

**Error Response Format**:
```go
type ErrorResponse struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}
```

### 3. Service Layer

**CheckInService**: Manages conversation flow and data extraction

```go
package service

type CheckInService struct {
    repo          *repository.CheckInRepository
    aiClient      *azure.OpenAIClient
    speechClient  *azure.SpeechServiceClient
    blobClient    *azure.BlobStorageClient
    questionFlow  *QuestionFlow
    dataExtractor *DataExtractor
    logger        *zap.Logger
}

func NewCheckInService(
    repo *repository.CheckInRepository,
    aiClient *azure.OpenAIClient,
    speechClient *azure.SpeechServiceClient,
    blobClient *azure.BlobStorageClient,
    logger *zap.Logger,
) *CheckInService

// Core methods
func (s *CheckInService) StartSession(ctx context.Context, userID string) (*SessionWithAudio, error)
func (s *CheckInService) StreamAudioToSpeech(ctx context.Context, sessionID string, audioStream io.Reader) (string, error)
func (s *CheckInService) ProcessResponse(ctx context.Context, sessionID string, response string) (*ConversationStateWithAudio, error)
func (s *CheckInService) GetQuestionAudio(ctx context.Context, sessionID string, questionID string) ([]byte, error)
func (s *CheckInService) CompleteSession(ctx context.Context, sessionID string) (*HealthCheckIn, error)
func (s *CheckInService) GetSessionStatus(ctx context.Context, sessionID string) (*SessionStatus, error)
```

**SessionWithAudio**: Extended session response with audio

```go
type SessionWithAudio struct {
    Session      *Session
    QuestionText string
    QuestionAudio []byte // WAV audio data
}

type ConversationStateWithAudio struct {
    SessionID     string
    QuestionText  string
    QuestionAudio []byte
    IsComplete    bool
}
```

**Audio Streaming Flow**:

```go
func (s *CheckInService) StreamAudioToSpeech(ctx context.Context, sessionID string, audioStream io.Reader) (string, error) {
    // 1. Stream audio to Azure Speech Service for real-time transcription
    transcription, err := s.speechClient.StreamAudioToText(ctx, audioStream)
    if err != nil {
        s.logger.Error("speech-to-text failed", "session_id", sessionID, "error", err)
        return "", fmt.Errorf("transcription failed: %w", err)
    }
    
    // 2. Save audio recording to blob storage asynchronously
    go func() {
        audioFileName := fmt.Sprintf("recordings/%s/%s.wav", sessionID, uuid.New().String())
        if err := s.blobClient.UploadAudio(context.Background(), audioFileName, audioStream); err != nil {
            s.logger.Error("failed to save audio recording", "session_id", sessionID, "error", err)
        }
    }()
    
    // 3. Return transcription immediately
    return transcription, nil
}
```

**Question Audio Generation**:

```go
func (s *CheckInService) GetQuestionAudio(ctx context.Context, sessionID string, questionID string) ([]byte, error) {
    // Get question text
    question := s.questionFlow.GetQuestionByID(questionID)
    if question == nil {
        return nil, ErrQuestionNotFound
    }
    
    // Check if audio is cached in blob storage
    cacheKey := fmt.Sprintf("question-audio/%s/%s.wav", "hu-HU", questionID)
    audioData, err := s.blobClient.DownloadAudio(ctx, cacheKey)
    if err == nil {
        return audioData, nil
    }
    
    // Generate audio using Text-to-Speech
    audioData, err = s.speechClient.TextToSpeech(ctx, question.TextHU, "hu-HU")
    if err != nil {
        return nil, fmt.Errorf("TTS failed: %w", err)
    }
    
    // Cache audio for future use
    go func() {
        if err := s.blobClient.UploadAudio(context.Background(), cacheKey, bytes.NewReader(audioData)); err != nil {
            s.logger.Error("failed to cache question audio", "question_id", questionID, "error", err)
        }
    }()
    
    return audioData, nil
}
```

**StartSession with Audio**:

```go
func (s *CheckInService) StartSession(ctx context.Context, userID string) (*SessionWithAudio, error) {
    // Create session
    session := &Session{
        ID:        uuid.New().String(),
        UserID:    userID,
        StartedAt: time.Now(),
        Status:    SessionStatusActive,
    }
    
    if err := s.repo.CreateSession(ctx, session); err != nil {
        return nil, err
    }
    
    // Get first question
    firstQuestion := s.questionFlow.GetNextQuestion()
    
    // Generate audio for first question
    audioData, err := s.GetQuestionAudio(ctx, session.ID, firstQuestion.ID)
    if err != nil {
        s.logger.Warn("failed to generate question audio", "error", err)
        // Continue without audio
    }
    
    return &SessionWithAudio{
        Session:       session,
        QuestionText:  firstQuestion.TextHU,
        QuestionAudio: audioData,
    }, nil
}
```

**QuestionFlow**: Manages the sequence of health questions

```go
type QuestionFlow struct {
    questions []Question
    current   int
}

type Question struct {
    ID       string
    TextHU   string
    Type     QuestionType // OpenEnded, Numeric, YesNo
    Required bool
}

func (qf *QuestionFlow) GetNextQuestion() *Question
func (qf *QuestionFlow) IsComplete() bool
```

**Hungarian Question Set**:
1. "Szia! Hogy érzed magad ma?" (How do you feel today?)
2. "Sportoltál ma, vagy mentél sétálni?" (Did you exercise or go for a walk today?)
3. "Mit reggeliztél/ebédeltél/vacsoráztál?" (What did you have for breakfast/lunch/dinner?)
4. "Fáj valamid?" (Does anything hurt today?)
5. "Hogyan aludtál?" (How did you sleep?)
6. "Milyen az energiaszinted?" (What's your energy level?)
7. "Beszedtél ma bármi gyógyszert?" (Did you take your medications?)
8. "Van még valami, amit szeretnél mondani?" (Anything else you'd like to note?)

**DataExtractor**: Extracts structured data using Azure OpenAI

```go
type DataExtractor struct {
    aiClient *azure.OpenAIClient
    logger   *zap.Logger
}

type ExtractedData struct {
    Symptoms         []string
    Mood             string // positive, neutral, negative
    PainLevel        *int   // 0-10, nil if no pain
    EnergyLevel      string // low, medium, high
    SleepQuality     string // poor, fair, good, excellent
    MedicationTaken  string // yes, no, partial
    PhysicalActivity []string
    Meals            MealInfo
    GeneralFeeling   string
    AdditionalNotes  string
}

type MealInfo struct {
    Breakfast string
    Lunch     string
    Dinner    string
}

func (de *DataExtractor) Extract(ctx context.Context, conversationHistory []Message) (*ExtractedData, error)
```

**AI Extraction Prompt Template**:
```
You are a medical data extraction assistant. Extract structured health information from the following conversation in Hungarian.

Conversation:
{conversation_history}

Extract the following information in JSON format:
- symptoms: list of symptoms mentioned
- mood: positive/neutral/negative
- pain_level: 0-10 or null
- energy_level: low/medium/high
- sleep_quality: poor/fair/good/excellent
- medication_taken: yes/no/partial
- physical_activity: list of activities
- meals: {breakfast, lunch, dinner}
- general_feeling: free text
- additional_notes: free text

Return only valid JSON.
```

**MedicationService**: Manages medication tracking

```go
type MedicationService struct {
    repo   *repository.MedicationRepository
    logger *zap.Logger
}

func (s *MedicationService) AddMedication(ctx context.Context, userID string, med *Medication) error
func (s *MedicationService) ListMedications(ctx context.Context, userID string) ([]Medication, error)
func (s *MedicationService) UpdateMedication(ctx context.Context, medID string, updates *MedicationUpdate) error
func (s *MedicationService) DeleteMedication(ctx context.Context, medID string) error
```

**HealthDataService**: Manages health metrics

```go
type HealthDataService struct {
    repo   *repository.HealthDataRepository
    logger *zap.Logger
}

func (s *HealthDataService) LogMenstruation(ctx context.Context, userID string, data *MenstruationData) error
func (s *HealthDataService) GetMenstruationHistory(ctx context.Context, userID string) ([]MenstruationCycle, error)
func (s *HealthDataService) LogBloodPressure(ctx context.Context, userID string, reading *BloodPressureReading) error
func (s *HealthDataService) GetBloodPressureHistory(ctx context.Context, userID string) ([]BloodPressureReading, error)
func (s *HealthDataService) SyncFitnessData(ctx context.Context, userID string, fitnessData []FitnessDataPoint) error
func (s *HealthDataService) GetFitnessHistory(ctx context.Context, userID string, startDate, endDate time.Time) ([]FitnessDataPoint, error)
```

**Fitness Data Sync**:

```go
type FitnessDataPoint struct {
    UserID       string
    Date         time.Time
    DataType     string // steps, heart_rate, sleep, calories, distance, active_minutes
    Value        float64
    Unit         string // count, bpm, minutes, kcal, meters
    Source       string // health_connect, google_fit
    SourceDataID string // Original ID from Health Connect
}

func (s *HealthDataService) SyncFitnessData(ctx context.Context, userID string, fitnessData []FitnessDataPoint) error {
    // Validate and deduplicate data
    for _, dataPoint := range fitnessData {
        // Check if data point already exists (by source_data_id)
        exists, err := s.repo.FitnessDataExists(ctx, dataPoint.SourceDataID)
        if err != nil {
            return fmt.Errorf("failed to check fitness data existence: %w", err)
        }
        
        if exists {
            s.logger.Debug("fitness data already synced", "source_data_id", dataPoint.SourceDataID)
            continue
        }
        
        // Save new data point
        if err := s.repo.SaveFitnessData(ctx, &dataPoint); err != nil {
            return fmt.Errorf("failed to save fitness data: %w", err)
        }
    }
    
    s.logger.Info("fitness data synced", "user_id", userID, "count", len(fitnessData))
    return nil
}
```

**DashboardService**: Aggregates data for dashboard

```go
type DashboardService struct {
    repo   *repository.DashboardRepository
    logger *zap.Logger
}

type DashboardSummary struct {
    Period          string
    AveragePain     float64
    MoodDistribution map[string]int
    EnergyLevels    map[string]int
    CheckInCount    int
    TimeSeriesData  []DailyMetrics
}

func (s *DashboardService) GetSummary(ctx context.Context, userID string, days int) (*DashboardSummary, error)
func (s *DashboardService) GetTrends(ctx context.Context, userID string, days int) (*TrendAnalysis, error)
```

**ReportService**: Generates PDF reports

```go
type ReportService struct {
    repo        *repository.ReportRepository
    healthRepo  *repository.HealthDataRepository
    blobClient  *azure.BlobStorageClient
    pdfGen      *PDFGenerator
    logger      *zap.Logger
}

func (s *ReportService) GenerateReport(ctx context.Context, userID string, startDate, endDate time.Time) (string, error)
func (s *ReportService) GetReport(ctx context.Context, reportID string) ([]byte, error)
```

### 4. Repository Layer

**CheckInRepository**: Manages check-in session data

```go
package repository

type CheckInRepository struct {
    db     *pgxpool.Pool
    logger *zap.Logger
}

func (r *CheckInRepository) CreateSession(ctx context.Context, session *Session) error
func (r *CheckInRepository) GetSession(ctx context.Context, sessionID string) (*Session, error)
func (r *CheckInRepository) UpdateSession(ctx context.Context, session *Session) error
func (r *CheckInRepository) SaveConversationMessage(ctx context.Context, sessionID string, msg *Message) error
func (r *CheckInRepository) SaveHealthCheckIn(ctx context.Context, checkIn *HealthCheckIn) error
```

**MedicationRepository**: Manages medication data

```go
func (r *MedicationRepository) Create(ctx context.Context, med *Medication) error
func (r *MedicationRepository) FindByUserID(ctx context.Context, userID string) ([]Medication, error)
func (r *MedicationRepository) Update(ctx context.Context, med *Medication) error
func (r *MedicationRepository) Delete(ctx context.Context, medID string) error
func (r *MedicationRepository) LogAdherence(ctx context.Context, log *MedicationLog) error
```

**HealthDataRepository**: Manages health metrics

```go
func (r *HealthDataRepository) SaveMenstruation(ctx context.Context, data *MenstruationCycle) error
func (r *HealthDataRepository) GetMenstruationByUserID(ctx context.Context, userID string) ([]MenstruationCycle, error)
func (r *HealthDataRepository) SaveBloodPressure(ctx context.Context, reading *BloodPressureReading) error
func (r *HealthDataRepository) GetBloodPressureByUserID(ctx context.Context, userID string) ([]BloodPressureReading, error)
```

**DashboardRepository**: Aggregates dashboard data

```go
func (r *DashboardRepository) GetHealthCheckIns(ctx context.Context, userID string, startDate, endDate time.Time) ([]HealthCheckIn, error)
func (r *DashboardRepository) GetAggregatedMetrics(ctx context.Context, userID string, days int) (*AggregatedMetrics, error)
```

### 5. External Service Clients

**Azure Speech Service Client**:

```go
package azure

type SpeechServiceClient struct {
    subscriptionKey string
    region          string
    endpoint        string
    logger          *zap.Logger
}

func NewSpeechServiceClient(subscriptionKey, region string, logger *zap.Logger) (*SpeechServiceClient, error)

// Speech-to-Text: Stream audio and get real-time transcription
func (c *SpeechServiceClient) StreamAudioToText(ctx context.Context, audioStream io.Reader) (string, error)

// Text-to-Speech: Convert question text to audio
func (c *SpeechServiceClient) TextToSpeech(ctx context.Context, text string, language string) ([]byte, error)

// Batch transcription for saved recordings
func (c *SpeechServiceClient) TranscribeAudioFile(ctx context.Context, audioURL string) (string, error)
```

**Speech-to-Text Implementation**:

```go
func (c *SpeechServiceClient) StreamAudioToText(ctx context.Context, audioStream io.Reader) (string, error) {
    // Use Azure Speech SDK for Go
    config, err := speech.NewSpeechConfigFromSubscription(c.subscriptionKey, c.region)
    if err != nil {
        return "", fmt.Errorf("failed to create speech config: %w", err)
    }
    defer config.Close()
    
    config.SetSpeechRecognitionLanguage("hu-HU") // Hungarian
    
    // Create audio config from stream
    audioConfig, err := audio.NewAudioConfigFromStreamInput(audioStream)
    if err != nil {
        return "", fmt.Errorf("failed to create audio config: %w", err)
    }
    defer audioConfig.Close()
    
    // Create speech recognizer
    recognizer, err := speech.NewSpeechRecognizerFromConfig(config, audioConfig)
    if err != nil {
        return "", fmt.Errorf("failed to create recognizer: %w", err)
    }
    defer recognizer.Close()
    
    // Start continuous recognition
    recognizer.SessionStarted(func(event speech.SessionEventArgs) {
        c.logger.Info("speech recognition session started", "session_id", event.SessionID)
    })
    
    var transcription strings.Builder
    recognizer.Recognized(func(event speech.SpeechRecognitionEventArgs) {
        if event.Result.Reason == speech.RecognizedSpeech {
            transcription.WriteString(event.Result.Text)
            transcription.WriteString(" ")
        }
    })
    
    recognizer.StartContinuousRecognitionAsync()
    defer recognizer.StopContinuousRecognitionAsync()
    
    // Wait for completion or context cancellation
    <-ctx.Done()
    
    return strings.TrimSpace(transcription.String()), nil
}
```

**Text-to-Speech Implementation**:

```go
func (c *SpeechServiceClient) TextToSpeech(ctx context.Context, text string, language string) ([]byte, error) {
    config, err := speech.NewSpeechConfigFromSubscription(c.subscriptionKey, c.region)
    if err != nil {
        return nil, fmt.Errorf("failed to create speech config: %w", err)
    }
    defer config.Close()
    
    config.SetSpeechSynthesisLanguage(language) // "hu-HU" for Hungarian
    config.SetSpeechSynthesisVoiceName("hu-HU-NoemiNeural") // Hungarian female voice
    
    // Synthesize to in-memory stream
    synthesizer, err := speech.NewSpeechSynthesizerFromConfig(config, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create synthesizer: %w", err)
    }
    defer synthesizer.Close()
    
    result, err := synthesizer.SpeakTextAsync(text).Get()
    if err != nil {
        return nil, fmt.Errorf("synthesis failed: %w", err)
    }
    defer result.Close()
    
    if result.Reason != speech.SynthesizingAudioCompleted {
        return nil, fmt.Errorf("synthesis failed with reason: %v", result.Reason)
    }
    
    return result.AudioData, nil
}
```

**Azure OpenAI Client**:

```go
package azure

type OpenAIClient struct {
    client   *azopenai.Client
    deployment string
    logger   *zap.Logger
}

func NewOpenAIClient(endpoint, apiKey, deployment string, logger *zap.Logger) (*OpenAIClient, error)

func (c *OpenAIClient) Complete(ctx context.Context, messages []azopenai.ChatMessage) (string, error)
```

**Azure Blob Storage Client**:

```go
type BlobStorageClient struct {
    client        *azblob.Client
    containerName string
    logger        *zap.Logger
}

func NewBlobStorageClient(accountName, accountKey, containerName string, logger *zap.Logger) (*BlobStorageClient, error)

func (c *BlobStorageClient) UploadPDF(ctx context.Context, filename string, data []byte) (string, error)
func (c *BlobStorageClient) DownloadPDF(ctx context.Context, blobName string) ([]byte, error)
func (c *BlobStorageClient) UploadAudio(ctx context.Context, filename string, audioStream io.Reader) (string, error)
func (c *BlobStorageClient) DownloadAudio(ctx context.Context, blobName string) ([]byte, error)
```

**Audio Upload Implementation**:

```go
func (c *BlobStorageClient) UploadAudio(ctx context.Context, filename string, audioStream io.Reader) (string, error) {
    blobClient := c.client.ServiceClient().NewContainerClient(c.containerName).NewBlockBlobClient(filename)
    
    _, err := blobClient.UploadStream(ctx, audioStream, &azblob.UploadStreamOptions{
        Metadata: map[string]*string{
            "content-type": to.Ptr("audio/wav"),
        },
    })
    if err != nil {
        return "", fmt.Errorf("failed to upload audio: %w", err)
    }
    
    return filename, nil
}
```

**PDF Generator**:

```go
package pdf

type PDFGenerator struct {
    logger *zap.Logger
}

type ReportData struct {
    UserName           string
    DateRange          string
    CheckIns           []HealthCheckIn
    Medications        []Medication
    BloodPressure      []BloodPressureReading
    MenstruationCycles []MenstruationCycle
    FitnessData        []FitnessDataPoint
}

func (g *PDFGenerator) Generate(data *ReportData) ([]byte, error)
```

## Data Models

### Database Schema

**users table**:
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMP
);
```

**check_in_sessions table**:
```sql
CREATE TABLE check_in_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    started_at TIMESTAMP NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMP,
    expired_at TIMESTAMP,
    status VARCHAR(50) NOT NULL, -- active, completed, expired
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_check_in_sessions_user_id ON check_in_sessions(user_id);
CREATE INDEX idx_check_in_sessions_status ON check_in_sessions(status);
```

**conversation_messages table**:
```sql
CREATE TABLE conversation_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES check_in_sessions(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL, -- assistant, user
    content TEXT NOT NULL,
    audio_file_path VARCHAR(500), -- Azure Blob Storage path for audio recording
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_conversation_messages_session_id ON conversation_messages(session_id);
```

**audio_recordings table**:
```sql
CREATE TABLE audio_recordings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_id UUID NOT NULL REFERENCES check_in_sessions(id) ON DELETE CASCADE,
    message_id UUID REFERENCES conversation_messages(id) ON DELETE SET NULL,
    file_path VARCHAR(500) NOT NULL, -- Azure Blob Storage path
    duration_seconds FLOAT,
    transcription TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_audio_recordings_session_id ON audio_recordings(session_id);
CREATE INDEX idx_audio_recordings_message_id ON audio_recordings(message_id);
```

**health_check_ins table**:
```sql
CREATE TABLE health_check_ins (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_id UUID REFERENCES check_in_sessions(id) ON DELETE SET NULL,
    check_in_date DATE NOT NULL,
    symptoms TEXT[], -- array of symptom strings
    mood VARCHAR(50), -- positive, neutral, negative
    pain_level INTEGER CHECK (pain_level >= 0 AND pain_level <= 10),
    energy_level VARCHAR(50), -- low, medium, high
    sleep_quality VARCHAR(50), -- poor, fair, good, excellent
    medication_taken VARCHAR(50), -- yes, no, partial
    physical_activity TEXT[], -- array of activity strings
    breakfast TEXT,
    lunch TEXT,
    dinner TEXT,
    general_feeling TEXT,
    additional_notes TEXT,
    raw_transcript TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_health_check_ins_user_id ON health_check_ins(user_id);
CREATE INDEX idx_health_check_ins_date ON health_check_ins(check_in_date);
```

**medications table**:
```sql
CREATE TABLE medications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    dosage VARCHAR(255) NOT NULL,
    frequency VARCHAR(255) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE,
    notes TEXT,
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_medications_user_id ON medications(user_id);
CREATE INDEX idx_medications_active ON medications(active);
```

**medication_logs table**:
```sql
CREATE TABLE medication_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    medication_id UUID NOT NULL REFERENCES medications(id) ON DELETE CASCADE,
    taken_at TIMESTAMP NOT NULL,
    adherence BOOLEAN NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_medication_logs_medication_id ON medication_logs(medication_id);
```

**menstruation_cycles table**:
```sql
CREATE TABLE menstruation_cycles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    start_date DATE NOT NULL,
    end_date DATE,
    flow_intensity VARCHAR(50), -- light, moderate, heavy
    symptoms TEXT[], -- array of symptom strings
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_menstruation_cycles_user_id ON menstruation_cycles(user_id);
CREATE INDEX idx_menstruation_cycles_start_date ON menstruation_cycles(start_date);
```

**blood_pressure_readings table**:
```sql
CREATE TABLE blood_pressure_readings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    systolic INTEGER NOT NULL CHECK (systolic >= 70 AND systolic <= 250),
    diastolic INTEGER NOT NULL CHECK (diastolic >= 40 AND diastolic <= 150),
    pulse INTEGER NOT NULL CHECK (pulse >= 30 AND pulse <= 220),
    measured_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_blood_pressure_readings_user_id ON blood_pressure_readings(user_id);
CREATE INDEX idx_blood_pressure_readings_measured_at ON blood_pressure_readings(measured_at);
```

**fitness_data table**:
```sql
CREATE TABLE fitness_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    data_type VARCHAR(50) NOT NULL, -- steps, heart_rate, sleep, calories, distance, active_minutes
    value FLOAT NOT NULL,
    unit VARCHAR(50) NOT NULL, -- count, bpm, minutes, kcal, meters
    source VARCHAR(50) NOT NULL, -- health_connect, google_fit
    source_data_id VARCHAR(255) UNIQUE, -- Original ID from Health Connect for deduplication
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_fitness_data_user_id ON fitness_data(user_id);
CREATE INDEX idx_fitness_data_date ON fitness_data(date);
CREATE INDEX idx_fitness_data_type ON fitness_data(data_type);
CREATE UNIQUE INDEX idx_fitness_data_source_id ON fitness_data(source_data_id);
```

**reports table**:
```sql
CREATE TABLE reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    date_range_start DATE NOT NULL,
    date_range_end DATE NOT NULL,
    file_path VARCHAR(500) NOT NULL, -- Azure Blob Storage path
    generated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_reports_user_id ON reports(user_id);
```

### Go Domain Models

```go
package model

type User struct {
    ID        string
    Name      string
    Email     string
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt *time.Time
}

type Session struct {
    ID          string
    UserID      string
    StartedAt   time.Time
    CompletedAt *time.Time
    ExpiredAt   *time.Time
    Status      SessionStatus
    Messages    []Message
}

type SessionStatus string

const (
    SessionStatusActive    SessionStatus = "active"
    SessionStatusCompleted SessionStatus = "completed"
    SessionStatusExpired   SessionStatus = "expired"
)

type Message struct {
    ID        string
    SessionID string
    Role      MessageRole
    Content   string
    CreatedAt time.Time
}

type MessageRole string

const (
    MessageRoleAssistant MessageRole = "assistant"
    MessageRoleUser      MessageRole = "user"
)

type HealthCheckIn struct {
    ID               string
    UserID           string
    SessionID        *string
    CheckInDate      time.Time
    Symptoms         []string
    Mood             *string
    PainLevel        *int
    EnergyLevel      *string
    SleepQuality     *string
    MedicationTaken  *string
    PhysicalActivity []string
    Breakfast        *string
    Lunch            *string
    Dinner           *string
    GeneralFeeling   *string
    AdditionalNotes  *string
    RawTranscript    *string
    CreatedAt        time.Time
    UpdatedAt        time.Time
}

type Medication struct {
    ID        string
    UserID    string
    Name      string
    Dosage    string
    Frequency string
    StartDate time.Time
    EndDate   *time.Time
    Notes     *string
    Active    bool
    CreatedAt time.Time
    UpdatedAt time.Time
}

type MedicationLog struct {
    ID           string
    MedicationID string
    TakenAt      time.Time
    Adherence    bool
    CreatedAt    time.Time
}

type MenstruationCycle struct {
    ID            string
    UserID        string
    StartDate     time.Time
    EndDate       *time.Time
    FlowIntensity *string
    Symptoms      []string
    CreatedAt     time.Time
    UpdatedAt     time.Time
}

type BloodPressureReading struct {
    ID         string
    UserID     string
    Systolic   int
    Diastolic  int
    Pulse      int
    MeasuredAt time.Time
    CreatedAt  time.Time
}

type FitnessDataPoint struct {
    ID           string
    UserID       string
    Date         time.Time
    DataType     string // steps, heart_rate, sleep, calories, distance, active_minutes
    Value        float64
    Unit         string // count, bpm, minutes, kcal, meters
    Source       string // health_connect, google_fit
    SourceDataID string // Original ID from Health Connect
    CreatedAt    time.Time
}

type Report struct {
    ID             string
    UserID         string
    DateRangeStart time.Time
    DateRangeEnd   time.Time
    FilePath       string
    GeneratedAt    time.Time
    CreatedAt      time.Time
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*


### Property 1: Session Creation Generates Unique IDs
*For any* user initiating a check-in, creating a new session should result in a session with a unique UUID and a valid timestamp.
**Validates: Requirements 1.1**

### Property 2: Session Creation Returns First Question
*For any* newly created check-in session, the system should return the first health question in Hungarian.
**Validates: Requirements 1.2**

### Property 3: Response Storage and Progression
*For any* active session and non-empty user response, submitting the response should store it in conversation history and return the next question.
**Validates: Requirements 1.3, 2.3**

### Property 4: Session Completion After All Questions
*For any* session where all mandatory questions have been answered, the system should allow marking the session as completed.
**Validates: Requirements 1.4, 2.5**

### Property 5: Data Extraction Triggers on Completion
*For any* completed check-in session, the system should trigger data extraction and create a HealthCheckIn record.
**Validates: Requirements 1.5, 1.6**

### Property 6: Session Timeout After Inactivity
*For any* check-in session with no activity for more than 30 minutes, the system should mark the session status as expired.
**Validates: Requirements 1.7**

### Property 7: Conversation Time Limit
*For any* check-in session, the total conversation duration should not exceed 10 minutes before the system initiates wrap-up.
**Validates: Requirements 2.6**

### Property 8: Data Extraction Output Structure
*For any* completed conversation history processed by the data extractor, the output should contain all required fields (symptoms list, mood enum, pain level 0-10 or null, energy enum, sleep enum, adherence enum, activities list, meal structure, general feeling text) with correct data types.
**Validates: Requirements 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10**

### Property 9: AI Failure Fallback
*For any* check-in session where Azure OpenAI extraction fails, the system should store the raw conversation transcript and mark the check-in for manual review.
**Validates: Requirements 3.12**

### Property 10: Medication CRUD Preserves ID
*For any* medication record, updating the medication should preserve the original medication ID while modifying other fields.
**Validates: Requirements 4.3**

### Property 11: Medication Deletion Removes Record
*For any* medication, deleting it should result in the medication no longer appearing in the user's medication list.
**Validates: Requirements 4.4**

### Property 12: Inactive Medication Retention
*For any* medication with an end date in the past, the system should mark it as inactive but retain the record in the database for historical purposes.
**Validates: Requirements 4.5**

### Property 13: List Sorting Consistency
*For any* user requesting their medications, menstruation cycles, or blood pressure readings, the returned list should be sorted by the appropriate date field (start date for medications and menstruation, measured_at for blood pressure) in the correct order.
**Validates: Requirements 4.2, 5.2, 6.5**

### Property 14: Input Validation Rejects Invalid Ranges
*For any* blood pressure reading with systolic outside 70-250, diastolic outside 40-150, or pulse outside 30-220, the system should reject the input with a validation error.
**Validates: Requirements 6.2, 6.3, 6.4**

### Property 15: Enum Validation
*For any* menstruation cycle with flow intensity, the value should be one of: light, moderate, or heavy. Invalid values should be rejected.
**Validates: Requirements 5.3**

### Property 16: Dashboard Time Range Filtering
*For any* dashboard request with a specified time range (7, 30, or 90 days), the returned data should only include health check-ins within that period.
**Validates: Requirements 7.2**

### Property 17: Dashboard Aggregation Accuracy
*For any* set of health check-ins in a time period, the dashboard summary should correctly compute average pain levels, mood distribution percentages, and energy level distribution.
**Validates: Requirements 7.3**

### Property 18: Time Series Data Grouping
*For any* dashboard time-series request, the data should be grouped by date with all available metrics included for each date.
**Validates: Requirements 7.4**

### Property 19: Report Content Completeness
*For any* generated report, the PDF should contain all required sections: symptoms timeline, medication list, medication adherence, blood pressure trends, menstruation cycles, physical activities, meal patterns, and daily check-in summaries.
**Validates: Requirements 8.2**

### Property 20: Report Storage and Retrieval Round Trip
*For any* generated report, storing it in Azure Blob Storage and then retrieving it by report ID should return the same PDF content.
**Validates: Requirements 8.3, 8.4**

### Property 21: Data Deletion Completeness
*For any* user requesting data deletion, all associated health records (check-ins, medications, menstruation cycles, blood pressure readings, reports) should be removed from the database.
**Validates: Requirements 10.3**

### Property 22: Data Export Completeness
*For any* user requesting data export, the returned JSON should contain all user data including profile, check-ins, medications, menstruation cycles, blood pressure readings, and reports.
**Validates: Requirements 10.4**

### Property 23: Audit Log Creation
*For any* data modification operation (create, update, delete), the system should create an audit log entry with timestamp, user ID, operation type, and affected resource.
**Validates: Requirements 10.5**

### Property 24: Error Response Structure
*For any* API error (400, 404, 500, 503), the response should be valid JSON containing an error code, message, and optional details field.
**Validates: Requirements 11.1, 11.2, 11.3, 11.5, 11.6**

### Property 25: Request Validation Completeness
*For any* API request, the validation should check required fields, data types, and value ranges before processing, rejecting invalid requests with specific error messages.
**Validates: Requirements 11.4**

### Property 26: Request Logging
*For any* API request received, the system should create a log entry containing request method, path, user ID (if authenticated), and timestamp.
**Validates: Requirements 12.1**

### Property 27: Error Logging Detail
*For any* error that occurs during request processing, the system should log the error message, stack trace, and request context.
**Validates: Requirements 12.2**

### Property 28: AI Operation Logging
*For any* Azure OpenAI API call, the system should log the processing time and token usage.
**Validates: Requirements 12.3**

### Property 29: Session Completion Logging
*For any* completed check-in session, the system should log the session duration and number of message exchanges.
**Validates: Requirements 12.4**

### Property 30: Deprecation Warning Headers
*For any* deprecated API endpoint, the response should include a deprecation warning header indicating the deprecation status.
**Validates: Requirements 13.3**

## Error Handling

### Error Categories

1. **Validation Errors (400 Bad Request)**
   - Missing required fields
   - Invalid data types
   - Out-of-range values
   - Invalid enum values
   - Empty required strings

2. **Not Found Errors (404 Not Found)**
   - Non-existent session ID
   - Non-existent medication ID
   - Non-existent report ID
   - Non-existent user ID

3. **Internal Errors (500 Internal Server Error)**
   - Database connection failures
   - Unexpected panics
   - Data corruption
   - PDF generation failures

4. **Service Unavailable (503 Service Unavailable)**
   - Azure OpenAI API unavailable
   - Azure Blob Storage unavailable
   - Database connection pool exhausted

### Error Response Format

All errors follow a consistent JSON structure:

```json
{
  "code": "VALIDATION_ERROR",
  "message": "Invalid blood pressure reading",
  "details": "Systolic value must be between 70 and 250"
}
```

### Error Codes

- `VALIDATION_ERROR`: Request validation failed
- `NOT_FOUND`: Resource not found
- `INTERNAL_ERROR`: Internal server error
- `SERVICE_UNAVAILABLE`: External service unavailable
- `SESSION_EXPIRED`: Check-in session expired
- `AI_EXTRACTION_FAILED`: AI data extraction failed

### Panic Recovery

All HTTP handlers are wrapped with Gin's recovery middleware to catch panics and return 500 errors:

```go
router.Use(gin.Recovery())
```

### Database Error Handling

Database errors are categorized and translated:

```go
func translateDBError(err error) error {
    if errors.Is(err, pgx.ErrNoRows) {
        return ErrNotFound
    }
    if pgxErr, ok := err.(*pgconn.PgError); ok {
        switch pgxErr.Code {
        case "23505": // unique_violation
            return ErrDuplicateKey
        case "23503": // foreign_key_violation
            return ErrForeignKeyViolation
        }
    }
    return ErrInternal
}
```

### Retry Logic

Azure service calls implement exponential backoff retry:

```go
func (c *OpenAIClient) CompleteWithRetry(ctx context.Context, messages []azopenai.ChatMessage) (string, error) {
    maxRetries := 3
    baseDelay := 1 * time.Second
    
    for attempt := 0; attempt < maxRetries; attempt++ {
        result, err := c.Complete(ctx, messages)
        if err == nil {
            return result, nil
        }
        
        if !isRetryable(err) {
            return "", err
        }
        
        delay := baseDelay * time.Duration(1<<attempt)
        time.Sleep(delay)
    }
    
    return "", ErrServiceUnavailable
}
```

## Testing Strategy

### Dual Testing Approach

The Eva Health Assistant backend requires both unit tests and property-based tests to ensure comprehensive coverage:

- **Unit tests**: Verify specific examples, edge cases, and error conditions
- **Property tests**: Verify universal properties across all inputs using randomized testing

Both testing approaches are complementary and necessary. Unit tests catch concrete bugs in specific scenarios, while property tests verify general correctness across a wide range of inputs.

### Property-Based Testing

**Library**: Use [gopter](https://github.com/leanovate/gopter) for property-based testing in Go

**Configuration**: Each property test should run a minimum of 100 iterations to ensure adequate coverage through randomization.

**Test Tagging**: Each property test must include a comment referencing the design document property:

```go
// Feature: eva-health-backend, Property 1: Session Creation Generates Unique IDs
func TestProperty_SessionCreationGeneratesUniqueIDs(t *testing.T) {
    properties := gopter.NewProperties(nil)
    
    properties.Property("session IDs are unique", prop.ForAll(
        func(userID string) bool {
            session1, _ := service.StartSession(ctx, userID)
            session2, _ := service.StartSession(ctx, userID)
            return session1.ID != session2.ID
        },
        gen.AnyString(),
    ))
    
    properties.TestingRun(t, gopter.ConsoleReporter(false))
}
```

**Property Test Coverage**: Each correctness property listed in this document must be implemented as a property-based test.

### Unit Testing

**Library**: Use Go's standard `testing` package with `testify/assert` for assertions

**Test Organization**:
- Handler tests: Test HTTP request/response handling
- Service tests: Test business logic with mocked dependencies
- Repository tests: Test database operations with test database
- Integration tests: Test end-to-end flows

**Example Unit Test**:

```go
func TestCheckInHandler_StartSession_Success(t *testing.T) {
    // Arrange
    mockService := &MockCheckInService{}
    handler := NewCheckInHandler(mockService, logger)
    
    expectedSession := &Session{
        ID:     "test-session-id",
        UserID: "test-user-id",
        Status: SessionStatusActive,
    }
    mockService.On("StartSession", mock.Anything, "test-user-id").Return(expectedSession, nil)
    
    // Act
    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = httptest.NewRequest("POST", "/api/v1/checkin/start", strings.NewReader(`{"user_id":"test-user-id"}`))
    handler.PostApiV1CheckinStart(c)
    
    // Assert
    assert.Equal(t, http.StatusOK, w.Code)
    mockService.AssertExpectations(t)
}
```

### Test Database

Use testcontainers for integration tests with PostgreSQL:

```go
package integration_test

import (
    "context"
    "testing"
    
    "github.com/stretchr/testify/require"
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/testcontainers/testcontainers-go/wait"
)

func setupTestDB(t *testing.T) (string, func()) {
    ctx := context.Background()
    
    postgresContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:15-alpine"),
        postgres.WithDatabase("eva_test"),
        postgres.WithUsername("test"),
        postgres.WithPassword("test"),
        testcontainers.WithWaitStrategy(
            wait.ForLog("database system is ready to accept connections").
                WithOccurrence(2).
                WithStartupTimeout(5*time.Second)),
    )
    require.NoError(t, err)
    
    connString, err := postgresContainer.ConnectionString(ctx, "sslmode=disable")
    require.NoError(t, err)
    
    // Run migrations
    runMigrations(t, connString)
    
    cleanup := func() {
        if err := postgresContainer.Terminate(ctx); err != nil {
            t.Logf("failed to terminate container: %s", err)
        }
    }
    
    return connString, cleanup
}

func TestIntegration(t *testing.T) {
    t.Parallel()
    
    connString, cleanup := setupTestDB(t)
    defer cleanup()
    
    // Run integration tests
    t.Run("CheckInFlow", testCheckInFlow(connString))
    t.Run("MedicationManagement", testMedicationManagement(connString))
    t.Run("HealthDataTracking", testHealthDataTracking(connString))
}
```

### Mocking External Services

Mock Azure services for unit tests:

```go
type MockOpenAIClient struct {
    mock.Mock
}

func (m *MockOpenAIClient) Complete(ctx context.Context, messages []azopenai.ChatMessage) (string, error) {
    args := m.Called(ctx, messages)
    return args.String(0), args.Error(1)
}
```

### Test Coverage Goals

- Unit test coverage: 80%+ for service and repository layers
- Property test coverage: 100% of correctness properties
- Integration test coverage: All critical user flows

### Continuous Integration

Tests run automatically on every commit:

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.26'
      - run: go test -v -race -coverprofile=coverage.out ./...
      - run: go tool cover -html=coverage.out -o coverage.html
```

## Configuration Management

### Environment Variables

Configuration is managed through environment variables:

```go
type Config struct {
    // Server
    ServerPort string `mapstructure:"SERVER_PORT"`
    
    // Database
    DatabaseURL string `mapstructure:"DATABASE_URL"`
    
    // Azure OpenAI
    AzureOpenAIEndpoint   string `mapstructure:"AZURE_OPENAI_ENDPOINT"`
    AzureOpenAIKey        string `mapstructure:"AZURE_OPENAI_KEY"`
    AzureOpenAIDeployment string `mapstructure:"AZURE_OPENAI_DEPLOYMENT"`
    
    // Azure Blob Storage
    AzureBlobAccountName string `mapstructure:"AZURE_BLOB_ACCOUNT_NAME"`
    AzureBlobAccountKey  string `mapstructure:"AZURE_BLOB_ACCOUNT_KEY"`
    AzureBlobContainer   string `mapstructure:"AZURE_BLOB_CONTAINER"`
    
    // Application
    LogLevel              string `mapstructure:"LOG_LEVEL"`
    SessionTimeoutMinutes int    `mapstructure:"SESSION_TIMEOUT_MINUTES"`
}

func LoadConfig() (*Config, error) {
    viper.SetConfigFile(".env")
    viper.AutomaticEnv()
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}
```

### Example .env File

```env
SERVER_PORT=8080
DATABASE_URL=postgres://user:password@localhost:5432/eva_health
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com/
AZURE_OPENAI_KEY=your-api-key
AZURE_OPENAI_DEPLOYMENT=gpt-4o
AZURE_SPEECH_KEY=your-speech-key
AZURE_SPEECH_REGION=westeurope
AZURE_BLOB_ACCOUNT_NAME=your-storage-account
AZURE_BLOB_ACCOUNT_KEY=your-storage-key
AZURE_BLOB_CONTAINER=health-reports
LOG_LEVEL=info
SESSION_TIMEOUT_MINUTES=30
```

## Project Structure

```
apps/backend/
├── main.go                         # Application entry point (existing)
├── internal/
│   ├── handler/
│   │   ├── checkin.go              # Check-in handlers
│   │   ├── medication.go           # Medication handlers
│   │   ├── health.go               # Health data handlers
│   │   ├── dashboard.go            # Dashboard handlers
│   │   └── report.go               # Report handlers
│   ├── service/
│   │   ├── checkin.go              # Check-in business logic
│   │   ├── question_flow.go        # Question management
│   │   ├── data_extractor.go      # AI data extraction
│   │   ├── medication.go           # Medication logic
│   │   ├── health.go               # Health data logic
│   │   ├── dashboard.go            # Dashboard aggregation
│   │   └── report.go               # Report generation
│   ├── repository/
│   │   ├── checkin.go              # Check-in data access
│   │   ├── medication.go           # Medication data access
│   │   ├── health.go               # Health data access
│   │   └── dashboard.go            # Dashboard data access
│   ├── azure/
│   │   ├── openai.go               # Azure OpenAI client
│   │   ├── speech.go               # Azure Speech Service client
│   │   └── blob.go                 # Azure Blob Storage client
│   ├── pdf/
│   │   └── generator.go            # PDF generation
│   └── config/
│       └── config.go               # Configuration management
├── pkg/
│   ├── api/
│   │   ├── generated.go            # Generated by oapi-codegen
│   │   └── oapi-codegen-cfg.yaml   # Code generation config
│   └── model/
│       └── models.go               # Domain models (shared)
├── integration-tests/
│   ├── checkin_test.go             # Check-in integration tests
│   ├── medication_test.go          # Medication integration tests
│   ├── health_test.go              # Health data integration tests
│   └── testcontainers_setup.go    # Testcontainers setup
├── migrations/                     # Existing migrations folder
│   ├── 000001_init_schema.up.sql  # Existing migration
│   ├── 000001_init_schema.down.sql
│   ├── 000002_add_health_tables.up.sql
│   └── ...
├── go.mod                          # Existing
├── go.sum                          # Existing
├── Dockerfile                      # Existing
└── README.md                       # Existing

api/                                # Project root
└── openapi.json                    # OpenAPI specification
```

## Deployment Considerations

### Database Migrations

Use golang-migrate for database migrations:

```bash
migrate -path migrations -database "postgres://user:pass@localhost:5432/eva_health" up
```

### Health Checks

Implement health check endpoint:

```go
func (h *HealthHandler) GetHealth(c *gin.Context) {
    // Check database
    if err := h.db.Ping(c.Request.Context()); err != nil {
        c.JSON(http.StatusServiceUnavailable, gin.H{"status": "unhealthy", "database": "down"})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{"status": "healthy"})
}
```

### Graceful Shutdown

Implement graceful shutdown:

```go
func main() {
    srv := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
}
```

### Azure Deployment

The backend can be deployed to Azure App Service or Azure Container Instances. Terraform configuration should include:

- App Service or Container Instance
- PostgreSQL Flexible Server
- Azure Blob Storage container
- Application Insights for monitoring
- Key Vault for secrets management

## Security Considerations

### Data Encryption

- **At Rest**: PostgreSQL transparent data encryption (TDE)
- **In Transit**: HTTPS/TLS 1.3 for all API endpoints
- **Sensitive Fields**: Additional AES-256 encryption for health data fields

### Input Sanitization

All user inputs are validated and sanitized:

```go
func sanitizeInput(input string) string {
    // Remove potentially dangerous characters
    input = strings.TrimSpace(input)
    input = html.EscapeString(input)
    return input
}
```

### SQL Injection Prevention

Use parameterized queries with pgx:

```go
func (r *CheckInRepository) GetSession(ctx context.Context, sessionID string) (*Session, error) {
    query := `SELECT id, user_id, started_at, completed_at, status FROM check_in_sessions WHERE id = $1`
    var session Session
    err := r.db.QueryRow(ctx, query, sessionID).Scan(&session.ID, &session.UserID, &session.StartedAt, &session.CompletedAt, &session.Status)
    return &session, err
}
```

### Rate Limiting

Implement rate limiting to prevent abuse:

```go
func RateLimitMiddleware() gin.HandlerFunc {
    limiter := rate.NewLimiter(rate.Every(time.Second), 10) // 10 requests per second
    
    return func(c *gin.Context) {
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, ErrorResponse{
                Code:    "RATE_LIMIT_EXCEEDED",
                Message: "Too many requests",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
```

## Monitoring and Observability

### Structured Logging

Use structured logging with zap:

```go
logger, _ := zap.NewProduction()
defer logger.Sync()

logger.Info("check-in session started",
    zap.String("session_id", sessionID),
    zap.String("user_id", userID),
    zap.Time("timestamp", time.Now()),
)
```

### Metrics

Track key metrics:

- Request count by endpoint
- Request duration by endpoint
- Error rate by type
- AI processing time
- Database query duration
- Active sessions count

### Tracing

Implement distributed tracing for debugging:

```go
func TracingMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        traceID := uuid.New().String()
        c.Set("trace_id", traceID)
        c.Header("X-Trace-ID", traceID)
        c.Next()
    }
}
```

## Future Enhancements

### Health Connect Integration

Prepare data models for future Health Connect integration:

```go
type FitnessData struct {
    ID         string
    UserID     string
    Date       time.Time
    Steps      *int
    HeartRate  *int
    SleepHours *float64
    Source     string // "health_connect"
    CreatedAt  time.Time
}
```

### Multi-language Support

Design conversation flow to support multiple languages:

```go
type QuestionFlow struct {
    questions map[string][]Question // language code -> questions
    language  string
}

func (qf *QuestionFlow) GetNextQuestion(lang string) *Question {
    questions := qf.questions[lang]
    // ...
}
```

### Advanced AI Insights

Prepare for future AI-powered insights:

```go
type HealthInsight struct {
    ID          string
    UserID      string
    InsightType string // "trend", "anomaly", "recommendation"
    Title       string
    Description string
    Confidence  float64
    GeneratedAt time.Time
}
```
